require("dotenv").config(); // Load environment variables from .env file
const express = require("express");
const cors = require("cors");
const mongoose = require("mongoose");
const jwt = require("jsonwebtoken");
const User = require("./model/user.model"); // Import the user model
const bcrypt = require("bcryptjs");

const app = express();
const port = process.env.PORT || 5000;

app.use(cors());
app.use(express.json());

app.get("/", (req, res) => {
  res.send("Vholamart Is Running Now");
});

// MongoDB connection using Mongoose
const uri = process.env.MONGO_URL;
if (!uri) {
  throw new Error("MongoDB connection string is not defined in the environment variables");
}

mongoose
  .connect(uri, { useNewUrlParser: true, useUnifiedTopology: true })
  .then(() => console.log("Connected to MongoDB using Mongoose"))
  .catch((err) => {
    console.error(err);
    process.exit(1);
  });

// Helper function to generate JWT
const generateToken = (user) => {
  return jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: "1h" });
};

// Register API
app.post("/signup", async (req, res) => {
  const { name, mobile, email, password } = req.body;
  try {
    // Check if the user already exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: "User already exists" });
    }

    // Create new user
    const newUser = new User({
      name,
      mobile,
      email,
      password, // Password will be hashed automatically before saving
    });
    await newUser.save();

    // Generate token for the new user
    const token = generateToken(newUser);
    res.status(201).json({ token, user: { id: newUser._id, name: newUser.name, email: newUser.email } });
  } catch (error) {
    console.error("Error during registration:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
});

// Login API
app.post("/login", async (req, res) => {
  const { email, password } = req.body;
  try {
    // Check if the user exists
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(400).send({ message: "Invalid email or password" });
    }

    // Compare password
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      return res.status(400).send({ message: "Invalid email or password" });
    }

    // Generate token
    const token = generateToken(user);
    res.status(200).send({ token, user: { id: user._id, name: user.name, email: user.email } });
  } catch (error) {
    res.status(500).send({ message: "Error logging in", error });
  }
});

// Middleware to protect routes
const protect = (req, res, next) => {
  let token;
  if (req.headers.authorization && req.headers.authorization.startsWith("Bearer")) {
    token = req.headers.authorization.split(" ")[1]; // Get token from "Bearer <token>"
  }

  if (!token) {
    return res.status(401).send({ message: "Not authorized, no token" });
  }

  // Verify token
  jwt.verify(token, process.env.JWT_SECRET, (err, decoded) => {
    if (err) {
      return res.status(401).send({ message: "Not authorized, token failed" });
    }

    req.user = decoded.id; // Set the user ID from the decoded token
    next();
  });
};

// Protected route example
app.get("/protected", protect, (req, res) => {
  res.send({ message: "This is a protected route", userId: req.user });
});

// Categories and Products APIs using Mongoose Models
const Category = mongoose.model("Category", new mongoose.Schema({ name: String }));
const Product = mongoose.model("Product", new mongoose.Schema({ name: String, categoryName: String }));

// Get all products
app.get("/products", async (req, res) => {
  const products = await Product.find({});
  res.send(products);
});

// Get product by ID
app.get("/products/:id", async (req, res) => {
  try {
    const product = await Product.findById(req.params.id);
    if (!product) {
      return res.status(404).send({ message: "Product not found" });
    }
    res.send(product);
  } catch (error) {
    res.status(500).send({ message: "Internal Server Error" });
  }
});

// Get all categories
app.get("/categories", async (req, res) => {
  const categories = await Category.find({});
  res.send(categories);
});

// Get products by category name
app.get("/category/:name", async (req, res) => {
  try {
    const products = await Product.find({ categoryName: req.params.name });
    if (!products || products.length === 0) {
      return res.status(404).send({ message: "No products found for this category" });
    }
    res.send(products);
  } catch (error) {
    res.status(500).send({ message: "Internal Server Error" });
  }
});

// Start the server
app.listen(port, () => {
  console.log(`Vholamart Is Running Now on port ${port}`);
});
